\chapter{FaPS Networking}
\label{ch:faps-networking}

\author{Nico Kratky}
%

FaPS Networking is a custom UDP-based library that is mainly used for communication between FaPS (see \ref{ch:faps}) and different kinds of client, eg. FaPS-save (see \ref{ch:faps-save}) and the NodeJS server (see
\ref{sec:webserver}).

\section{TCP vs UDP in real time environments}

% comparison between TCP Header and UDP Header -> more Overhead -> more Information
% TCP -> feedback mechanism, not relevant in real time environments, when dropped packets are resent they are outdated and not relevant -> don't care when dropped
% TCP is perfect for transferring big files bc when one byte is missing whole file is corrupt
% reliability comes at cost -> much larger overhead!
%
% include images of headers!!!!

\cite{TCPUDPRTlifesize}

\todo{cite whole paragraph like this?}

\section {Handling Connections}

As UDP is a connectionless protocols, neither does it know if the other end of the communacation is ready to receive data nor if it is even existing. Therefor a way of handling connections using UDP had to implemented.

The core of this implementation is a map. A map is a associative container that is available through C++'s STL (Standard Template Library). This maps contains all clients as keys, and the associated timestamps of the last
received keepalive message as values.

After starting the server, two threads are started. The first one handles all incoming messages. If a received message is a keepalive message the timestamp of the client that sent this message is update
to the current time. The second thread monitors these timestamps. If the difference between the current timestamp and the stored timestamp of a client exceeds 1.5 seconds, the client is declared disconnected and removed
from the list.

Also when a client is instantiaed a thread is started to handle the keepalive messages. The only task of this thread is to send a keepalive message to the server and then wait one second. All of this is done in a loop that
only finishes when the clients deconstructor is called, thus disconnects.

\section {Handshake}

The handshake procedure is a very important part of connecting. This makes sure that the server is notified whenever a client is waiting to connect.

When the server receives a connection request (see \ref{tab:faps-networking-control-messages}), it has to check if it can accept further clients. This limit is set as a static constant in the \textit{Server} class. The
default value is \textbf{8}. If this check is successful the server sends an acknowledgement message to the client. If the check fails, the client will receive a connection refused message. In this implementation the
clients connect call will block until it is connected. This is done by a loop that will be exited once the server sends an acknowledgement. In between the connection attempts one second is waited.

These two procedures can be both seen in the code listings (\ref{lst:faps-networking-handshake-server} and \ref{lst:faps-networking-handshake-client}) and the sequence diagram (\ref{fig:faps-networking-handshake}) below.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Server handshake method}, label=lst:faps-networking-handshake-server, captionpos=b, language=C++]
void Server::shake_hands(boost::asio::ip::udp::endpoint& remote) {
    if (endpoints_.size() < MAX_CLIENTS_) {
        send(control_messages["ACKNOWLEDGE"], remote);
        endpoints_[remote] = std::chrono::system_clock::now();
    }
    else {
        send(control_messages["CONNECTION_REFUSED"], remote);
    }
}
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Client handshake method}, label=lst:faps-networking-handshake-client, captionpos=b, language=C++]
void Client::connect() {
    while (!connected) {
        send(control_messages["CONNECTION_REQUEST"]);

        std::string reply;
        receive(reply);

        if (reply.compare(control_messages["ACKNOWLEDGE"]) == 0) {
            connected = true;

            std::thread t_keepalive{&Client::keepalive, this};
            t_keepalive.detach();
        }
        else {
            std::this_thread::sleep_for(TIMEOUT_);
        }
    }
}
\end{lstlisting}
\end{minipage}

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm,keepaspectratio]{faps-networking-handshake}
    \caption{Handshake performed when a client tries to connect to server}
    \label{fig:faps-networking-handshake}
\end{figure}

\section{Control Message}

This table explains all control messages that can be exchanged.

\begin{table}[H]
    \centering
    \begin{tabular}{| l | l | p{5cm} |}
    \hline
    \textbf{Message} & \textbf{Sent to} & \textbf{Meaning} \\ \hline
    CRQ & server & Tells the server that a new client is waiting for the connection procedure \\ \hline
    ACK & client & Tells the client that the connection is acknowledged \\ \hline
    CRF & client & Tells the client that the server can not accept the connection \\ \hline
    KAV & server & Tells the server that the client is still alive and wants to stay connected \\
    \hline
    \end{tabular}
    \caption{Commands sent by one of the connection partners and what they do}
    \label{tab:faps-networking-control-messages}
\end{table}

