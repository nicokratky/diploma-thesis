\chapter{Filtering and Preprocessing System}
\label{ch:faps}

\author{Nico Kratky}
%
FaPS, which stands for Filtering and Preprocessing System, is an application that reads digital sensor output, preprocesses it and forwards it to another process to distribute it to the final clients. It also saves the readout to HDF5 files \cite{HDF5}.

\section{Command Line Parameter Parsing}

As FaPS is a command line program, arguments that are passed to it have to be parsed. This is done by Boosts program\_options \cite{BoostProgramOptions}. This module allows easy parsing and exception handling.

Following arguments can be passed to FaPS:

\begin{table}[H]
    \centering
    \begin{tabular}{| l | l | p{5cm} |}
    \hline
    \textbf{Flag} & \textbf{Argument} & \textbf{Meaning} \\ \hline
    -h, --help & & Outputs the usage information \\ \hline
    --ip & \textit{ip\_adress} & Sets the IP address to which FaPS will connect to read sensor data \\ \hline
    --in-port & \textit{port number} & Sets the port to which FaPS will connect to read sensor data \\ \hline
    --out-port & \textit{port nuymber} & Sets the port for the started UDP Server \\ \hline
    --file & \textit{filename} & Sets the filename to which the data will be saved \\ \hline
    --size & \textit{Filesize in MB} & Maximum file size that the log file will have \\ \hline
    -l, --level & \textit{loglevel} & Which log messages are logged \\
    \hline
    \end{tabular}
    \caption{Flags that can be set, which arguments they take and what they do or change}
    \label{tab:faps_arguments}
\end{table}

\section{Networking}

All networking related programming was done by utilizing Boosts Asio module. Asio is a cross-platform C++ library for network programming. \cite{BoostAsio}.

\section{Data Storage}

To be able to offer a possibility for further data inspection all received data is saved to HDF5 files. HDF stands for Hierarchical Data Format. It is a file format for storing large amounts of scientific data. A HDF5 file is organized hierarchically as the name suggests. This is achieved by following a tree structure and dividing the data into groups and datasets. The format of a HDF file can be compared to a file system with the exception that HDF groups are linked as a directed graph. This means that a HDF file allows circular references.

Every sensor readout is saved as a dataset that is identified by a number. This number represents a timestamp as microseconds since 1.1.1970 (also called Unix Time or epoch).

\section{Data Serialization}

% possible solution
% ===================
% explain all three (advantages, disadvantages)
%
% take a short[6][100] array
% use protobufs, json and bson to get a binary representation
%
% BIG advantage of json => easy usage in JS (json is a js object)


In order to send data so that the other end can interpret the message it has to be packed into a common format. To do this JSON is used \cite{rfc8259}. It is a language- and platform-independent data serialization format
originally specified by Douglas Crockford in the early 2000s. JSON is uses text in a human-readable form stores data in key-value pairs. Originally it was derived from JavaScript but as of today many programming languages
include methods and functions to en- and decode JSON.

\subsection{Other Data Serialization Formats}

\subsubsection{Protocol Buffers}

Protocol Buffer are a data serialization format that packs its data into a binary format, developed by Google. Although they offer a lot of advantages in contrast to JSON, it was decided to not use them as JavaScript is not fully supported yet.

\todo{protobuf support in js -> research}

\section{Data Distribution}

Once preprocessing and serialization is finished, the received sensor data has to be distributed to connected clients. This is a typical use case for inter-process communication.

\subsection{Unix Domain Sockets}

Unix domain sockets are a way of communicating between a client and a server that are on the same host. There are two types of sockets available: stream sockets (compareable to TCP) and datagram sockets (compareable to
UDP). Although this solutions seams ideal for this, it was quickly decided against it. The reason for this decisions is that NodeJS does not support datagram unix domain sockets anymore and real time application usually
make use of datagrams. Therefor regular UDP was used.

\subsection{Solution}

Several problems led to the developement of a custom UDP-based networking library that is discussed in chapter \ref{ch:faps-networking}.
